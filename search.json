[
  {
    "objectID": "demo.html",
    "href": "demo.html",
    "title": "rcrisp: a tool for automated morphological delineation of urban river spaces",
    "section": "",
    "text": "This is a computational notebook that illustrates how to use the rcrisp package in a programming enviroment. A computational notebook bundles together text, code cells (here written using the R programming language), and code output, such as figures or interactive maps.\nYou can find the source code of this document, as well as information on how to setup a programming environment with all required software dependencies in a public GitHub repository. This notebook is executed, rendered, and published online using the Quarto software.\n\n\n\n\n\n\nTiprcrisp as code\n\n\n\nWriting programming scripts or computational notebooks to perform research tasks (rcrisp related, but not only!) allows one to automate tedious and error-prone tasks, making analyses workflows faster, scalable and reproducible!"
  },
  {
    "objectID": "demo.html#introduction",
    "href": "demo.html#introduction",
    "title": "rcrisp: a tool for automated morphological delineation of urban river spaces",
    "section": "",
    "text": "This is a computational notebook that illustrates how to use the rcrisp package in a programming enviroment. A computational notebook bundles together text, code cells (here written using the R programming language), and code output, such as figures or interactive maps.\nYou can find the source code of this document, as well as information on how to setup a programming environment with all required software dependencies in a public GitHub repository. This notebook is executed, rendered, and published online using the Quarto software.\n\n\n\n\n\n\nTiprcrisp as code\n\n\n\nWriting programming scripts or computational notebooks to perform research tasks (rcrisp related, but not only!) allows one to automate tedious and error-prone tasks, making analyses workflows faster, scalable and reproducible!"
  },
  {
    "objectID": "demo.html#delineating-urban-river-areas",
    "href": "demo.html#delineating-urban-river-areas",
    "title": "rcrisp: a tool for automated morphological delineation of urban river spaces",
    "section": "Delineating urban river areas",
    "text": "Delineating urban river areas\nrcrisp implements three methods of morphological delineations of urban river areas (Forgaci, 2018), which are based on the following spatial units:\n\nthe river corridor,\nthe corridor segments,\nthe river space.\n\nThese units are based on infrastructure data (street & rail network, buildings). In addition, rcrisp also makes use of digital terrain data to estimate the river valley, the edges of which are used to “guide” the delineation of the river corridor."
  },
  {
    "objectID": "demo.html#data-sources",
    "href": "demo.html#data-sources",
    "title": "rcrisp: a tool for automated morphological delineation of urban river spaces",
    "section": "Data sources",
    "text": "Data sources\nBy default, rcrisp uses the following data sources:\n\nOpenStreetMap (OSM), mostly for street & rail network, buildings, and river geometry;\nGLO-30 Copernicus Digital Elevation Model (DEM) for the representation of the topographic surface of the area.\n\n.. but any other data sources could be used as well!"
  },
  {
    "objectID": "demo.html#an-example-of-delineation-the-dâmbovița-river-in-bucharest",
    "href": "demo.html#an-example-of-delineation-the-dâmbovița-river-in-bucharest",
    "title": "rcrisp: a tool for automated morphological delineation of urban river spaces",
    "section": "An example of delineation: the Dâmbovița river in Bucharest",
    "text": "An example of delineation: the Dâmbovița river in Bucharest\nWe start by importing the required software libraries: rcrisp, but also other R libraries for (geospatial) data analysis and visualization.\n\nlibrary(rcrisp)\nlibrary(ggplot2)\nlibrary(htmltools)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(tibble)\n\nWe also define some auxiliary functions that will facilitate the visualization of datasets on a base map:\n\n\nCode\n#' Visualize one or more vector or raster datasets on a base map\n#'\n#' @param ... objects to display on a map. If the coordinate reference\n#'   system is missing, lat/lon coordinates will be assumed (\"EPSG:4326\")\n#' @param col Color (sequence) to use for the input object(s)\n#' @param label Labels to use for the input object(s). If a vector, use its\n#'   elements to label the object features\n#' @param map Leaflet map object where to plot the geospatial objects\n#'\n#' @return Leaflet map\nvisualize &lt;- function(..., col = NULL, label = NULL, map = NULL) {\n  # Pack input obhects in a list\n  geometries &lt;- list(...)\n  ngeoms &lt;- length(geometries)\n\n  # Determine the sequence of colors\n  colors &lt;- get_colors(ngeoms, col = col)\n\n  # Initialize map\n  if (is.null(map)) map &lt;- addTiles(leaflet())\n\n  # Loop over objects to plot\n  for (n in seq_len(ngeoms)) {\n    geometry &lt;- geometries[[n]]\n    color &lt;- colors[[n]]\n\n    if (inherits(geometry, \"bbox\")) {\n      # If a bounding box, convert it to polygon\n      map &lt;- visualize(sf::st_as_sfc(geometry), col = color, map = map)\n    } else if (inherits(geometry, \"sfnetwork\")) {\n      # If a sfnetwork, extract edges and nodes\n      edges &lt;- sf::st_as_sf(geometry, \"edges\")\n      labels &lt;- get_edge_labels(edges)\n      map &lt;- visualize(edges, col = color, label = labels, map = map)\n      nodes &lt;- sf::st_as_sf(geometry, \"nodes\")\n      map &lt;- visualize(nodes, col = color, label = seq_len(nrow(nodes)),\n                       map = map)\n    } else if (inherits(geometry, \"SpatRaster\")) {\n      map &lt;- addRasterImage(map, geometry, opacity = 0.8)\n    } else if (inherits(geometry, \"sf\")) {\n      is_column_name &lt;- (\n        !is.null(label) && (length(label) == 1) && (label %in% names(geometry))\n      )\n      if (is_column_name) label &lt;- geometry[[label]]\n      map &lt;- visualize(sf::st_geometry(geometry), col = col, label = label,\n                       map = map)\n    } else if (inherits(geometry, \"sfc\")) {\n      geometry_type &lt;- sf::st_geometry_type(geometry, by_geometry = FALSE)\n      data &lt;- as.latlon(geometry)\n      if (is.in(\"linestring\", geometry_type)) {\n        map &lt;- addPolylines(map, data = data, color = color,\n                                     label = label)\n      } else if (is.in(\"point\", geometry_type)) {\n        map &lt;- addCircles(map, data = data, color = col,\n                                   label = label)\n      } else if (is.in(\"polygon\", geometry_type)) {\n        map &lt;- addPolygons(map, data = data, color = col,\n                                    label = label)\n      } else {\n        stop(sprintf(\"Cannot plot geometry type: %s\", geometry_type))\n      }\n    } else {\n      stop(paste0(\"Cannot plot data type \", class(geometry)))\n    }\n  }\n  map\n}\n\n#' @noRd\nget_colors &lt;- function(num_geometries, col = NULL) {\n  if (is.null(col)) {\n    # If color is NULL, determine colors from a palette\n    factpal &lt;- colorFactor(topo.colors(num_geometries),\n                                    factor(seq_len(num_geometries)))\n    col &lt;- sapply(seq_len(num_geometries), factpal)\n  } else if (length(col) == 1) {\n    # If we got a single color, use it for all geometries\n    col &lt;- rep(col, num_geometries)\n  }\n  # Make sure we have as many colors as geometries\n  stopifnot(length(col) == num_geometries)\n  col\n}\n\n#' @noRd\nis.in &lt;- function(x, y) grepl(x, y, ignore.case = TRUE)\n\n#' @noRd\nas.latlon &lt;- function(x) {\n  crs &lt;- st_crs(x)\n  # If no CRS is present, set it to lat/lon\n  if (is.na(crs)) st_crs(x) &lt;- st_crs(\"EPSG:4326\")\n  st_transform(x, 4326)\n}\n\n#' @noRd\nget_edge_labels &lt;- function(edges) {\n  ids &lt;- seq_len(nrow(edges))\n  lapply(sprintf(\"&lt;strong&gt;%d&lt;/strong&gt; %d -&gt; %d\", ids, edges$from, edges$to), HTML)\n}\n\n\nThe three types of morphological delineations described above can be carried out via the delineate function built in rcrisp, which works as main access point to the package functionality.\nLet’s start by defining the name of the city and of the river that we aim to delineate:\n\ncity_name &lt;- \"Bucharest\"\nriver_name &lt;- \"Dâmbovița\"\n\nWe can carry out the delineation by calling the delineate function:\n\ndelineations &lt;- delineate(\n  city_name,\n  river_name,\n  corridor = TRUE,\n  segments = TRUE,\n  riverspace = TRUE\n)\n\nDone! Let us visualize the results. delineations is a list, which contains:\n1. The urban corridor surrounding the river, delineated on the street network along a path that is closest to the valley edge:\n\nvisualize(delineations$corridor)\n\n\n\n\n\n2. The corridor segments, bounded by the main transversal streets:\n\nvisualize(delineations$segments)\n\n\n\n\n\n3. The river space, i.e. the space between the river and the first line of buildings:\n\nvisualize(delineations$riverspace)"
  },
  {
    "objectID": "demo.html#comparing-urban-rivers-how-green-is-the-corridor",
    "href": "demo.html#comparing-urban-rivers-how-green-is-the-corridor",
    "title": "rcrisp: a tool for automated morphological delineation of urban river spaces",
    "section": "Comparing urban rivers: how green is the corridor?",
    "text": "Comparing urban rivers: how green is the corridor?\nIn order to illustrate the potential of rcrisp in cross-case analyses, we show how we can use its spatial delineation units to answer questions like: which of the following urban areas is “greenest” in the surroundings of the city river?\n\ncity_river_names &lt;- tribble(\n  ~city_name,       ~river_name,\n  \"Bucharest\",      \"Dâmbovița\",\n  \"Warsaw\",         \"Wisła\",\n  \"Prague\",         \"Vltava\",\n  \"Roma\",           \"Tevere\",\n  \"Cairo, Egypt\",   \"Nile River\",\n  \"Madrid\",         \"Río Manzanares\",\n  \"Los Angeles\",    \"Los Angeles River\",\n  \"Paris\",          \"La Seine\",\n  \"Berlin\",         \"Spree\",\n  \"Rotterdam\",      \"Nieuwe Maas\",\n)\n\nWe thus delineate the corridors of the ten urban rivers listed above:\n\n# Create a list where to store all corridors\ncorridors &lt;- list()\n\n# Loop over city/river pairs\nfor (i in seq(nrow(city_river_names))) {\n  city_name &lt;- city_river_names$city_name[i]\n  river_name &lt;- city_river_names$river_name[i]\n\n  # Run the delineation for the selected city/river\n  delineations_city &lt;- delineate(\n    city_name = city_name,\n    river_name = river_name,\n    corridor = TRUE,\n  )\n\n  # Extract the corridor geometry, tranform to lat/lon\n  corridor &lt;- st_transform(delineations_city$corridor, \"EPSG:4326\")\n\n  # Record corridor for later usage\n  corridors[[city_name]] &lt;- corridor\n}\n\nLet’s visualize the results on a map:\n\ncentroids &lt;- do.call(c, lapply(corridors, st_centroid))\nmap &lt;- do.call(visualize, corridors)\naddMarkers(map, data = centroids)\n\n\n\n\n\nFor each corridor, we now retrieve landuse information from OSM to identify parks and other green areas.\n\n# Create a list where to store all green areas\ngreen_areas &lt;- list()\n\n# Loop over the delineated corridors\nfor (i in seq(length(corridors))) {\n  city_name &lt;- names(corridors[i])\n  corridor &lt;- corridors[[i]]\n\n  # Retrieve footprints of green areas based on OSM tags\n  parks &lt;- osmdata_as_sf(\"leisure\", \"park\", aoi = corridor)\n  natural &lt;- osmdata_as_sf(\"natural\", c(\"grassland\", \"woodland\", \"wood\"), aoi = corridor)\n\n  # Merge all footprints of green areas intersecting the corridor\n  all &lt;- c(parks$osm_polygons$geometry, natural$osm_polygons$geometry)\n  green_areas[[city_name]] &lt;- st_intersection(all, corridor) |&gt;\n    st_make_valid()\n}\n\nFor example, the green areas in the surrounding of the Seine river in Paris:\n\n# Visualize \"green\" areas retrieved in Paris\nm &lt;- visualize(corridors$Paris, col = \"blue\")\nm &lt;- visualize(green_areas$Paris, col = \"green\", map = m)\nm\n\n\n\n\n\nWe thus quantify the green surface, and divide it by the overall corridor surface:\n\n# Determine the \"green\" surface vs the total surface of the corridor\narea_green &lt;- lapply(green_areas, st_area) |&gt; sapply(sum)\narea_corridor &lt;- sapply(corridors, st_area)\nfrac &lt;- area_green / area_corridor * 100\n\nFinally we plot the ratio for the ten cities as a bar plot. Note how Warsaw and Cairo turn out to be the cities with the highest and lowest fraction of green surface, respectively.\n\ndata &lt;- data.frame(city = names(frac), percentage = unlist(frac))\nggplot(data, aes(x = city, y = percentage)) +\n  geom_col() +\n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))"
  }
]